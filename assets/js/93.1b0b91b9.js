(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{175:function(t,e,s){"use strict";s.r(e);var _=s(0),i=Object(_.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[t._m(0),t._v(" "),s("p",[t._v("缓存是性能优化中非常重要的一环，浏览器的缓存机制对开发也是非常重要的知识点。接下来以三个部分来把浏览器的缓存机制说清楚：")]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),s("p",[t._v("如何来检查呢？通过相应的字段来进行，但是说起这个字段就有点门道了。")]),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),s("p",[t._v("代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。")]),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),s("p",[t._v("即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。")]),t._v(" "),t._m(28),t._v(" "),t._m(29),t._v(" "),t._m(30),t._v(" "),t._m(31),t._v(" "),t._m(32),t._v(" "),t._m(33),t._v(" "),t._m(34),t._v(" "),t._m(35),t._v(" "),t._m(36),t._v(" "),t._m(37),t._v(" "),t._m(38),t._v(" "),t._m(39),t._v(" "),t._m(40),t._v(" "),t._m(41),t._v(" "),t._m(42),t._v(" "),s("p",[t._v("浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：")]),t._v(" "),t._m(43),t._v(" "),t._m(44),t._v(" "),t._m(45),t._v(" "),s("p",[t._v("Service Worker 同时也是 PWA 的重要实现机制，关于它的细节和特性，我们将会在后面的 PWA 的分享中详细介绍。")]),t._v(" "),t._m(46),t._v(" "),t._m(47),t._v(" "),t._m(48),t._v(" "),s("p",[t._v("好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：")]),t._v(" "),t._m(49),t._v(" "),t._m(50),t._v(" "),s("p",[t._v("即推送缓存，这是浏览器缓存的最后一道防线。它是 "),s("code",[t._v("HTTP/2")]),t._v(" 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。关于 Push Cache，有非常多的内容可以挖掘，不过这已经不是本文的重点，大家可以参考这篇"),s("a",{attrs:{href:"https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/",target:"_blank",rel:"noopener noreferrer"}},[t._v("扩展文章"),s("OutboundLink")],1),t._v("。")]),t._v(" "),t._m(51),t._v(" "),s("p",[t._v("对浏览器的缓存机制来做个简要的总结:")]),t._v(" "),t._m(52),t._v(" "),t._m(53)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"_001-能不能说一说前端缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_001-能不能说一说前端缓存","aria-hidden":"true"}},[this._v("#")]),this._v(" 001: 能不能说一说前端缓存?")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("强缓存")]),this._v(" "),e("li",[this._v("协商缓存")]),this._v(" "),e("li",[this._v("缓存位置")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存","aria-hidden":"true"}},[this._v("#")]),this._v(" 强缓存")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("浏览器中的缓存作用分为两种情况，一种是需要发送"),e("code",[this._v("HTTP")]),this._v("请求，一种是不需要发送。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("首先是检查强缓存，这个阶段"),e("code",[this._v("不需要")]),this._v("发送HTTP请求。")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("在"),s("code",[t._v("HTTP/1.0")]),t._v("和"),s("code",[t._v("HTTP/1.1")]),t._v("当中，这个字段是不一样的。在早期，也就是"),s("code",[t._v("HTTP/1.0")]),t._v("时期，使用的是"),s("strong",[t._v("Expires")]),t._v("，而"),s("code",[t._v("HTTP/1.1")]),t._v("使用的是"),s("strong",[t._v("Cache-Control")]),t._v("。让我们首先来看看Expires。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"expires"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#expires","aria-hidden":"true"}},[this._v("#")]),this._v(" Expires")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("Expires")]),this._v("即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("Expires"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Wed"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("22")]),t._v(" Nov "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2019")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("08")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("41")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("00")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("GMT")]),t._v("\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("表示资源在"),e("code",[this._v("2019年11月22号8点41分")]),this._v("过期，过期了就得向服务端发请求。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是"),e("strong",[this._v("服务器的时间和浏览器的时间可能并不一致")]),this._v("，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"cache-control"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cache-control","aria-hidden":"true"}},[this._v("#")]),this._v(" Cache-Control")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在HTTP1.1中，采用了一个非常关键的字段："),e("code",[this._v("Cache-Control")]),this._v("。这个字段也是存在于")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("它和"),e("code",[this._v("Expires")]),this._v("本质的不同在于它并没有采用"),e("code",[this._v("具体的过期时间点")]),this._v("这个方式，而是采用过期时长来控制缓存，对应的字段是"),e("strong",[this._v("max-age")]),this._v("。比如这个例子:")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("Cache"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Control"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("max"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("age"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3600")]),t._v("\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("如果你觉得它只有"),e("code",[this._v("max-age")]),this._v("一个属性的话，那就大错特错了。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("它其实可以组合非常多的指令，完成更多场景的缓存判断, 将一些关键的属性列举如下:\n"),e("strong",[this._v("public")]),this._v(": 客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的"),e("code",[this._v("代理服务器")]),this._v("最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("private")]),this._v("： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("no-cache")]),this._v(": 跳过当前的强缓存，发送HTTP请求，即直接进入"),e("code",[this._v("协商缓存阶段")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("no-store")]),this._v("：非常粗暴，不进行任何形式的缓存。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("s-maxage")]),this._v("：这和"),e("code",[this._v("max-age")]),this._v("长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("must-revalidate")]),this._v(": 是缓存就会有过期的时候，加上这个字段一旦缓存过期，就必须回到源服务器验证。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("值得注意的是，当"),e("strong",[this._v("Expires")]),this._v("和"),e("strong",[this._v("Cache-Control")]),this._v("同时存在的时候，"),e("strong",[this._v("Cache-Control")]),this._v("会优先考虑。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("当然，还存在一种情况，当资源缓存时间超时了，也就是"),e("code",[this._v("强缓存")]),this._v("失效了，接下来怎么办？没错，这样就进入到第二级屏障——"),e("strong",[this._v("协商缓存")]),this._v("了。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存","aria-hidden":"true"}},[this._v("#")]),this._v(" 协商缓存")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("强缓存失效之后，浏览器在请求头中携带相应的"),e("code",[this._v("缓存tag")]),this._v("来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是"),e("strong",[this._v("协商缓存")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("具体来说，这样的缓存tag分为两种: "),e("strong",[this._v("Last-Modified")]),this._v(" 和 "),e("strong",[this._v("ETag")]),this._v("。这两者各有优劣，并不存在谁对谁有"),e("code",[this._v("绝对的优势")]),this._v("，跟上面强缓存的两个 tag 不一样。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"last-modified"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#last-modified","aria-hidden":"true"}},[this._v("#")]),this._v(" Last-Modified")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("浏览器接收到后，如果再次请求，会在请求头中携带"),e("code",[this._v("If-Modified-Since")]),this._v("字段，这个字段的值也就是服务器传来的最后修改时间。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("服务器拿到请求头中的"),e("code",[this._v("If-Modified-Since")]),this._v("的字段后，其实会和这个服务器中"),e("code",[this._v("该资源的最后修改时间")]),this._v("对比:")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。")]),this._v(" "),e("li",[this._v("否则返回304，告诉浏览器直接用缓存。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"etag"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#etag","aria-hidden":"true"}},[this._v("#")]),this._v(" ETag")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("ETag")]),this._v(" 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过"),e("code",[this._v("响应头")]),this._v("把这个值给浏览器。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("浏览器接收到"),e("code",[this._v("ETag")]),this._v("的值，会在下次请求时，将这个值作为"),e("strong",[this._v("If-None-Match")]),this._v("这个字段的内容，并放到请求头中，然后发给服务器。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("服务器接收到"),e("strong",[this._v("If-None-Match")]),this._v("后，会跟服务器上该资源的"),e("strong",[this._v("ETag")]),this._v("进行比对:")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。")]),this._v(" "),e("li",[this._v("否则返回304，告诉浏览器直接用缓存。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"两者对比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#两者对比","aria-hidden":"true"}},[this._v("#")]),this._v(" 两者对比")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("在"),e("code",[this._v("精准度")]),this._v("上，"),e("code",[this._v("ETag")]),this._v("优于"),e("code",[this._v("Last-Modified")]),this._v("。优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。")]),this._v(" "),e("li",[this._v("Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。")])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ol",{attrs:{start:"2"}},[s("li",[t._v("在性能上，"),s("code",[t._v("Last-Modified")]),t._v("优于"),s("code",[t._v("ETag")]),t._v("，也很简单理解，"),s("code",[t._v("Last-Modified")]),t._v("仅仅只是记录一个时间点，而 "),s("code",[t._v("Etag")]),t._v("需要根据文件的具体内容生成哈希值。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("另外，如果两种方式都支持的话，服务器会优先考虑"),e("code",[this._v("ETag")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"缓存位置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存位置","aria-hidden":"true"}},[this._v("#")]),this._v(" 缓存位置")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("前面我们已经提到，当"),e("code",[this._v("强缓存")]),this._v("命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("Service Worker")]),this._v(" "),e("li",[this._v("Memory Cache")]),this._v(" "),e("li",[this._v("Disk Cache")]),this._v(" "),e("li",[this._v("Push Cache")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"service-worker"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#service-worker","aria-hidden":"true"}},[this._v("#")]),this._v(" Service Worker")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问"),s("code",[t._v("DOM")]),t._v("。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如"),s("code",[t._v("离线缓存")]),t._v("、"),s("code",[t._v("消息推送")]),t._v("和"),s("code",[t._v("网络代理")]),t._v("等功能。其中的"),s("code",[t._v("离线缓存")]),t._v("就是 "),s("strong",[t._v("Service Worker Cache")]),t._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"memory-cache-和-disk-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#memory-cache-和-disk-cache","aria-hidden":"true"}},[this._v("#")]),this._v(" Memory Cache 和 Disk Cache")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("Memory Cache")]),this._v("指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("Disk Cache")]),this._v("就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。稍微有些计算机基础的应该很好理解，就不展开了。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存")]),this._v(" "),e("li",[this._v("内存使用率比较高的时候，文件优先进入磁盘")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"push-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#push-cache","aria-hidden":"true"}},[this._v("#")]),this._v(" Push Cache")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[this._v("#")]),this._v(" 总结")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("首先通过 "),e("code",[this._v("Cache-Control")]),this._v(" 验证强缓存是否可用")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ul",[s("li",[t._v("如果强缓存可用，直接使用")]),t._v(" "),s("li",[t._v("否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的"),s("code",[t._v("If-Modified-Since")]),t._v("或者"),s("code",[t._v("If-None-Match")]),t._v("这些条件请求字段检查资源是否更新\n"),s("ul",[s("li",[t._v("若资源更新，返回资源和200状态码")]),t._v(" "),s("li",[t._v("否则，返回304，告诉浏览器直接从缓存获取资源")])])])])}],!1,null,null,null);e.default=i.exports}}]);