(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{196:function(e,t,v){"use strict";v.r(t);var a=v(0),_=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("div",{staticClass:"content"},[v("h1",{attrs:{id:"_012-如何理解-tcp-的-keep-alive？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_012-如何理解-tcp-的-keep-alive？","aria-hidden":"true"}},[e._v("#")]),e._v(" 012. 如何理解 TCP 的 keep-alive？")]),e._v(" "),v("p",[e._v("大家都听说过 http 的"),v("code",[e._v("keep-alive")]),e._v(", 不过 TCP 层面也是有"),v("code",[e._v("keep-alive")]),e._v("机制，而且跟应用层不太一样。")]),e._v(" "),v("p",[e._v("试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的。")]),e._v(" "),v("p",[e._v("这个时候就出现了 keep-alive, 它的作用就是探测对端的连接有没有失效。")]),e._v(" "),v("p",[e._v("在 Linux 下，可以这样查看相关的配置:")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("sudo sysctl -a | grep keepalive\n\n// 每隔 7200 s 检测一次\nnet.ipv4.tcp_keepalive_time = 7200\n// 一次最多重传 9 个包\nnet.ipv4.tcp_keepalive_probes = 9\n// 每个包的间隔重传间隔 75 s\nnet.ipv4.tcp_keepalive_intvl = 75\n")])])]),v("p",[e._v("不过，现状是大部分的应用并没有默认开启 TCP 的"),v("code",[e._v("keep-alive")]),e._v("选项，为什么？")]),e._v(" "),v("p",[e._v("站在应用的角度:")]),e._v(" "),v("ul",[v("li",[e._v("7200s 也就是两个小时检测一次，时间太长")]),e._v(" "),v("li",[e._v("时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接")])]),e._v(" "),v("p",[e._v("因此是一个比较尴尬的设计。")])])}],!1,null,null,null);t.default=_.exports}}]);