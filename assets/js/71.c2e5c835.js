(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{210:function(t,e,s){"use strict";s.r(e);var i=s(0),r=Object(i.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[t._m(0),t._v(" "),s("p",[t._v("在这里，如果你还没有接触过 Promise, 务必去看看 "),s("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise",target:"_blank",rel:"noopener noreferrer"}},[t._v("MDN 文档"),s("OutboundLink")],1),t._v("，了解使用方式，不然后面很会懵。")]),t._v(" "),s("p",[t._v("Promise 中的执行函数是同步进行的，但是里面存在着异步操作，在异步操作结束后会调用 resolve 方法，或者中途遇到错误调用 reject 方法，这两者都是作为微任务进入到 EventLoop 中。但是你有没有想过，Promise 为什么要引入微任务的方式来进行回调操作？")]),t._v(" "),t._m(1),t._v(" "),s("p",[t._v("回到问题本身，其实就是如何处理回调的问题。总结起来有三种方式:")]),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"_005-promise之问-二-——为什么promise要引入微任务？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_005-promise之问-二-——为什么promise要引入微任务？","aria-hidden":"true"}},[this._v("#")]),this._v(" 005: Promise之问(二)——为什么Promise要引入微任务？")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"解决方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解决方式","aria-hidden":"true"}},[this._v("#")]),this._v(" 解决方式")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ol",[s("li",[t._v("使用同步回调，直到异步任务进行完，再进行后面的任务。")]),t._v(" "),s("li",[t._v("使用异步回调，将回调函数放在进行"),s("code",[t._v("宏任务队列")]),t._v("的队尾。")]),t._v(" "),s("li",[t._v("使用异步回调，将回调函数放到"),s("code",[t._v("当前宏任务中")]),t._v("的最后面。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"优劣对比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优劣对比","aria-hidden":"true"}},[this._v("#")]),this._v(" 优劣对比")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("第一种方式显然不可取，因为同步的问题非常明显，会让整个脚本阻塞住，当前任务等待，后面的任务都无法得到执行，而这部分"),e("code",[this._v("等待的时间")]),this._v("是可以拿来完成其他事情的，导致 CPU 的利用率非常低，而且还有另外一个致命的问题，就是无法实现"),e("code",[this._v("延迟绑定")]),this._v("的效果。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("如果采用第二种方式，那么执行回调(resolve/reject)的时机应该是在前面"),e("code",[this._v("所有的宏任务")]),this._v("完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成"),e("code",[this._v("应用卡顿")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("为了解决上述方案的问题，另外也考虑到"),e("code",[this._v("延迟绑定")]),this._v("的需求，Promise 采取第三种方式, 即"),e("code",[this._v("引入微任务")]),this._v(", 即把 resolve(reject) 回调的执行放在当前宏任务的末尾。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("这样，利用"),e("code",[this._v("微任务")]),this._v("解决了两大痛点:")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("ol",[e("li",[this._v("采用"),e("strong",[this._v("异步回调")]),this._v("替代同步回调解决了浪费 CPU 性能的问题。")])])]),this._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[this._v("放到"),e("strong",[this._v("当前宏任务最后")]),this._v("执行，解决了回调执行的实时性问题。")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("好，Promise 的基本实现思想已经讲清楚了，相信大家已经知道了它"),e("code",[this._v("为什么这么设计")]),this._v("，接下来就让我们一步步弄清楚它内部到底是"),e("code",[this._v("怎么设计的")]),this._v("。")])}],!1,null,null,null);e.default=r.exports}}]);