(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{224:function(t,_,a){"use strict";a.r(_);var v=a(0),e=Object(v.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_039-描述一下-v8-执行一段js代码的过程？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_039-描述一下-v8-执行一段js代码的过程？","aria-hidden":"true"}},[t._v("#")]),t._v(" 039: 描述一下 V8 执行一段JS代码的过程？")]),t._v(" "),a("p",[t._v("前端相对来说是一个比较新兴的领域，因此各种前端框架和工具层出不穷，让人眼花缭乱，尤其是各大厂商推出"),a("code",[t._v("小程序")]),t._v("之后"),a("code",[t._v("各自制定标准")]),t._v("，让前端开发的工作更加繁琐，在此背景下为了抹平平台之间的差异，诞生的各种"),a("code",[t._v("编译工具/框架")]),t._v("也数不胜数。但无论如何，想要赶上这些框架和工具的更新速度是非常难的，即使赶上了也很难产生自己的"),a("code",[t._v("技术积淀")]),t._v("，一个更好的方式便是学习那些"),a("code",[t._v("本质的知识")]),t._v("，抓住上层应用中不变的"),a("code",[t._v("底层机制")]),t._v("，这样我们便能轻松理解上层的框架而不仅仅是被动地使用，甚至能够在适当的场景下自己造出轮子，以满足开发效率的需求。")]),t._v(" "),a("p",[t._v("站在 V8 的角度，理解其中的执行机制，也能够帮助我们理解很多的上层应用，包括Babel、Eslint、前端框架的底层机制。那么，一段 JavaScript 代码放在 V8 当中究竟是如何执行的呢？")]),t._v(" "),a("p",[t._v("首先需要明白的是，机器是读不懂 JS 代码，机器只能理解特定的机器码，那如果要让 JS 的逻辑在机器上运行起来，就必须将 JS 的代码翻译成机器码，然后让机器识别。JS属于解释型语言，对于解释型的语言说，解释器会对源代码做如下分析:")]),t._v(" "),a("ul",[a("li",[t._v("通过词法分析和语法分析生成 AST(抽象语法树)")]),t._v(" "),a("li",[t._v("生成字节码")])]),t._v(" "),a("p",[t._v("然后解释器根据字节码来执行程序。但 JS 整个执行的过程其实会比这个更加复杂，接下来就来一一地拆解。")]),t._v(" "),a("h2",{attrs:{id:"_1-生成-ast"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-生成-ast","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.生成 AST")]),t._v(" "),a("p",[t._v("生成 AST 分为两步——词法分析和语法分析。")]),t._v(" "),a("p",[t._v("词法分析即分词，它的工作就是将一行行的代码分解成一个个token。 比如下面一行代码:")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'sanyuan'")]),t._v("\n")])])]),a("p",[t._v("其中会把句子分解成四个部分:")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/week07/7.jpg"),alt:"project"}}),t._v(" "),a("p",[t._v("即解析成了四个token，这就是词法分析的作用。")]),t._v(" "),a("p",[t._v("接下来语法分析阶段，将生成的这些 token 数据，根据一定的语法规则转化为AST。举个例子:")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'sanyuan'")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("最后生成的 AST 是这样的:")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/week07/8.jpg"),alt:"project"}}),t._v(" "),a("p",[t._v("当生成了 AST 之后，编译器/解释器后续的工作都要依靠 AST 而不是源代码。顺便补充一句，babel 的工作原理就是将ES5 的代码解析生成"),a("code",[t._v("ES5的AST")]),t._v("，然后将ES5 的 AST 转换为 "),a("code",[t._v("ES6 的AST")]),t._v(",最后才将 ES6 的 AST 转化为具体的 ES6 代码。由于本文着重阐述原理，关于 babel 编译的细节就不展开了，推荐大家去读一读荒山的"),a("a",{attrs:{href:"https://juejin.im/post/5d94bfbf5188256db95589be",target:"_blank",rel:"noopener noreferrer"}},[t._v("babel文章"),a("OutboundLink")],1),t._v(", 帮你打开新世界的大门: )")]),t._v(" "),a("p",[t._v("回到 V8 本身，生成 AST 后，接下来会生成执行上下文，关于执行上下文，可以参考上上篇《JavaScript内存机制之问——数据是如何存储的？》中对于上下文压栈出栈过程的讲解。")]),t._v(" "),a("h2",{attrs:{id:"_2-生成字节码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-生成字节码","aria-hidden":"true"}},[t._v("#")]),t._v(" 2. 生成字节码")]),t._v(" "),a("p",[t._v("开头就已经提到过了，生成 AST 之后，直接通过 V8 的解释器(也叫Ignition)来生成字节码。但是"),a("code",[t._v("字节码")]),t._v("并不能让机器直接运行，那你可能就会说了，不能执行还转成字节码干嘛，直接把 AST 转换成机器码不就得了，让机器直接执行。确实，在 V8 的早期是这么做的，但后来因为机器码的体积太大，引发了严重的内存占用问题。")]),t._v(" "),a("p",[t._v("给一张对比图让大家直观地感受以下三者代码量的差异:")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/week07/9.jpg"),alt:"project"}}),t._v(" "),a("p",[t._v("很容易得出，字节码是比机器码轻量得多的代码。那 V8 为什么要使用字节码，字节码到底是个什么东西？")]),t._v(" "),a("blockquote",[a("p",[t._v("子节码是介于AST 和 机器码之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行。")])]),t._v(" "),a("p",[t._v("字节码仍然需要转换为机器码，但和原来不同的是，现在不用一次性将全部的字节码都转换成机器码，而是通过解释器来逐行执行字节码，省去了生成二进制文件的操作，这样就大大降低了内存的压力。")]),t._v(" "),a("h2",{attrs:{id:"_3-执行代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-执行代码","aria-hidden":"true"}},[t._v("#")]),t._v(" 3. 执行代码")]),t._v(" "),a("p",[t._v("接下来，就进入到字节码解释执行的阶段啦！")]),t._v(" "),a("p",[t._v("在执行字节码的过程中，如果发现某一部分代码重复出现，那么 V8 将它记做"),a("code",[t._v("热点代码")]),t._v("(HotSpot)，然后将这么代码编译成"),a("code",[t._v("机器码")]),t._v("保存起来，这个用来编译的工具就是V8的"),a("code",[t._v("编译器")]),t._v("(也叫做"),a("code",[t._v("TurboFan")]),t._v(")\n, 因此在这样的机制下，代码执行的时间越久，那么执行效率会越来越高，因为有越来越多的字节码被标记为"),a("code",[t._v("热点代码")]),t._v("，遇到它们时直接执行相应的机器码，不用再次将转换为机器码。")]),t._v(" "),a("p",[t._v("其实当你听到有人说 JS 就是一门解释器语言的时候，其实这个说法是有问题的。因为字节码不仅配合了解释器，而且还和编译器打交道，所以 JS 并不是完全的解释型语言。而编译器和解释器的\n根本区别在于前者会编译生成二进制文件但后者不会。")]),t._v(" "),a("p",[t._v("并且，这种字节码跟编译器和解释器结合的技术，我们称之为"),a("code",[t._v("即时编译")]),t._v(", 也就是我们经常听到的"),a("code",[t._v("JIT")]),t._v("。")]),t._v(" "),a("p",[t._v("这就是 V8 中执行一段JS代码的整个过程，梳理一下:")]),t._v(" "),a("ol",[a("li",[t._v("首先通过词法分析和语法分析生成 "),a("code",[t._v("AST")])]),t._v(" "),a("li",[t._v("将 AST 转换为字节码")]),t._v(" "),a("li",[t._v("由解释器逐行执行字节码，遇到热点代码启动编译器进行编译，生成对应的机器码, 以优化执行效率")])]),t._v(" "),a("p",[t._v("关于这个问题的拆解就到这里，希望对你有所启发。")])])}),[],!1,null,null,null);_.default=e.exports}}]);