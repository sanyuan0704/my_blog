(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{566:function(_,v,t){"use strict";t.r(v);var e=t(4),s=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[_._v("TLS 1.2 虽然存在了 10 多年，经历了无数的考验，但历史的车轮总是不断向前的，为了获得更强的安全、更优秀的性能，在"),t("code",[_._v("2018年")]),_._v("就推出了 TLS1.3，对于"),t("code",[_._v("TLS1.2")]),_._v("做了一系列的改进，主要分为这几个部分:"),t("strong",[_._v("强化安全")]),_._v("、"),t("strong",[_._v("提高性能")]),_._v("。")]),_._v(" "),t("h2",{attrs:{id:"强化安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强化安全"}},[_._v("#")]),_._v(" 强化安全")]),_._v(" "),t("p",[_._v("在 TLS1.3 中废除了非常多的加密算法，最后只保留五个加密套件:")]),_._v(" "),t("ul",[t("li",[_._v("TLS_AES_128_GCM_SHA256")]),_._v(" "),t("li",[_._v("TLS_AES_256_GCM_SHA384")]),_._v(" "),t("li",[_._v("TLS_CHACHA20_POLY1305_SHA256")]),_._v(" "),t("li",[_._v("TLS_AES_128_GCM_SHA256")]),_._v(" "),t("li",[_._v("TLS_AES_128_GCM_8_SHA256")])]),_._v(" "),t("p",[_._v("可以看到，最后剩下的对称加密算法只有 "),t("strong",[_._v("AES")]),_._v(" 和 "),t("strong",[_._v("CHACHA20")]),_._v("，之前主流的也会这两种。分组模式也只剩下 "),t("strong",[_._v("GCM")]),_._v(" 和 "),t("strong",[_._v("POLY1305")]),_._v(", 哈希摘要算法只剩下了 "),t("strong",[_._v("SHA256")]),_._v(" 和 "),t("strong",[_._v("SHA384")]),_._v(" 了。")]),_._v(" "),t("p",[_._v("那你可能会问了, 之前"),t("code",[_._v("RSA")]),_._v("这么重要的非对称加密算法怎么不在了？")]),_._v(" "),t("p",[_._v("我觉得有两方面的原因:")]),_._v(" "),t("p",[t("strong",[_._v("第一")]),_._v("、2015年发现了"),t("code",[_._v("FREAK")]),_._v("攻击，即已经有人发现了 RSA 的漏洞，能够进行破解了。")]),_._v(" "),t("p",[t("strong",[_._v("第二")]),_._v("、一旦私钥泄露，那么中间人可以通过私钥计算出之前所有报文的"),t("code",[_._v("secret")]),_._v("，破解之前所有的密文。")]),_._v(" "),t("p",[_._v("为什么？回到 RSA 握手的过程中，客户端拿到服务器的证书后，提取出服务器的公钥，然后生成"),t("code",[_._v("pre_random")]),_._v("并用"),t("strong",[_._v("公钥")]),_._v("加密传给服务器，服务器通过"),t("strong",[_._v("私钥")]),_._v("解密，从而拿到真实的"),t("code",[_._v("pre_random")]),_._v("。当中间人拿到了服务器私钥，并且截获之前所有报文的时候，那么就能拿到"),t("code",[_._v("pre_random")]),_._v("、"),t("code",[_._v("server_random")]),_._v("和"),t("code",[_._v("client_random")]),_._v("并根据对应的随机数函数生成"),t("code",[_._v("secret")]),_._v("，也就是拿到了 TLS 最终的会话密钥，每一个历史报文都能通过这样的方式进行破解。")]),_._v(" "),t("p",[_._v("但"),t("code",[_._v("ECDHE")]),_._v("在每次握手时都会生成临时的密钥对，即使私钥被破解，之前的历史消息并不会收到影响。这种一次破解并不影响历史信息的性质也叫"),t("strong",[_._v("前向安全性")]),_._v("。")]),_._v(" "),t("p",[t("code",[_._v("RSA")]),_._v(" 算法不具备前向安全性，而 "),t("code",[_._v("ECDHE")]),_._v(" 具备，因此在 TLS1.3 中彻底取代了"),t("code",[_._v("RSA")]),_._v("。")]),_._v(" "),t("h2",{attrs:{id:"提升性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提升性能"}},[_._v("#")]),_._v(" 提升性能")]),_._v(" "),t("h3",{attrs:{id:"握手改进"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#握手改进"}},[_._v("#")]),_._v(" 握手改进")]),_._v(" "),t("p",[_._v("流程如下:\n"),t("img",{attrs:{src:_.$withBase("/http/011.jpg")}})]),_._v(" "),t("p",[_._v("大体的方式和 TLS1.2 差不多，不过和 TLS 1.2 相比少了一个 RTT， 服务端不必等待对方验证证书之后才拿到"),t("code",[_._v("client_params")]),_._v("，而是直接在第一次握手的时候就能够拿到, 拿到之后立即计算"),t("code",[_._v("secret")]),_._v("，节省了之前不必要的等待时间。同时，这也意味着在第一次握手的时候客户端需要传送更多的信息，一口气给传完。")]),_._v(" "),t("p",[_._v("这种 TLS 1.3 握手方式也被叫做"),t("strong",[_._v("1-RTT握手")]),_._v("。但其实这种"),t("code",[_._v("1-RTT")]),_._v("的握手方式还是有一些优化的空间的，接下来我们来一一介绍这些优化方式。")]),_._v(" "),t("h3",{attrs:{id:"会话复用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#会话复用"}},[_._v("#")]),_._v(" 会话复用")]),_._v(" "),t("p",[_._v("会话复用有两种方式: "),t("strong",[_._v("Session ID")]),_._v("和"),t("strong",[_._v("Session Ticket")]),_._v("。")]),_._v(" "),t("p",[_._v("先说说最早出现的"),t("strong",[_._v("Seesion ID")]),_._v("，具体做法是客户端和服务器首次连接后各自保存会话的 ID，并存储会话密钥，当再次连接时，客户端发送"),t("code",[_._v("ID")]),_._v("过来，服务器查找这个 ID 是否存在，如果找到了就直接复用之前的会话状态，会话密钥不用重新生成，直接用原来的那份。")]),_._v(" "),t("p",[_._v("但这种方式也存在一个弊端，就是当客户端数量庞大的时候，对服务端的存储压力非常大。")]),_._v(" "),t("p",[_._v("因而出现了第二种方式——"),t("strong",[_._v("Session Ticket")]),_._v("。它的思路就是: 服务端的压力大，那就把压力分摊给客户端呗。具体来说，双方连接成功后，服务器加密会话信息，用"),t("strong",[_._v("Session Ticket")]),_._v("消息发给客户端，让客户端保存下来。下次重连的时候，就把这个 Ticket 进行解密，验证它过没过期，如果没过期那就直接恢复之前的会话状态。")]),_._v(" "),t("p",[_._v("这种方式虽然减小了服务端的存储压力，但与带来了安全问题，即每次用一个固定的密钥来解密 Ticket 数据，一旦黑客拿到这个密钥，之前所有的历史记录也被破解了。因此为了尽量避免这样的问题，密钥需要定期进行更换。")]),_._v(" "),t("p",[_._v("总的来说，这些会话复用的技术在保证"),t("code",[_._v("1-RTT")]),_._v("的同时，也节省了生成会话密钥这些算法所消耗的时间，是一笔可观的性能提升。")]),_._v(" "),t("h3",{attrs:{id:"psk"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#psk"}},[_._v("#")]),_._v(" PSK")]),_._v(" "),t("p",[_._v("刚刚说的都是"),t("code",[_._v("1-RTT")]),_._v("情况下的优化，那能不能优化到"),t("code",[_._v("0-RTT")]),_._v("呢？")]),_._v(" "),t("p",[_._v("答案是可以的。做法其实也很简单，在发送"),t("strong",[_._v("Session Ticket")]),_._v("的同时带上应用数据，不用等到服务端确认，这种方式被称为"),t("code",[_._v("Pre-Shared Key")]),_._v("，即 PSK。")]),_._v(" "),t("p",[_._v("这种方式虽然方便，但也带来了安全问题。中间人截获"),t("code",[_._v("PSK")]),_._v("的数据，不断向服务器重复发，类似于 TCP 第一次握手携带数据，增加了服务器被攻击的风险。")]),_._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),t("p",[_._v("TLS1.3 在 TLS1.2 的基础上废除了大量的算法，提升了安全性。同时利用会话复用节省了重新生成密钥的时间，利用 PSK 做到了"),t("code",[_._v("0-RTT")]),_._v("连接。")])])}),[],!1,null,null,null);v.default=s.exports}}]);